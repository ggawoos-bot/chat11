<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>금연사업 지침 문의 Chatbot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-bg': '#131314',
              'brand-surface': '#1e1f20',
              'brand-primary': '#8ab4f8',
              'brand-secondary': '#4e5052',
              'brand-text-primary': '#e8eaed',
              'brand-text-secondary': '#bdc1c6',
            }
          }
        }
      }
    </script>
    <script type="importmap">
{
  "imports": {
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.16.0",
    "path": "https://aistudiocdn.com/path@^0.12.7",
    "vite": "https://aistudiocdn.com/vite@^7.1.3"
  }
}
</script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      // Set worker source for pdf.js from CDN
      pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
    </script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-brand-bg text-brand-text-primary">
    <div id="root"></div>
    <script src="functions.js"></script>
    <script src="components.js"></script>
    <script src="ui-components.js"></script>
    <script src="app.js"></script>
    <script type="text/babel" data-type="module">
      import { GoogleGenAI } from "@google/genai";

      const { useState, useCallback, useMemo, useRef, useEffect, StrictMode } = React;

      // LLM 서비스 타입 정의
      const LlmServiceType = {
        GEMINI: 'gemini',
        OLLAMA: 'ollama'
      };

      // --- Inlined from types.ts ---
      const Role = {
        USER: 'user',
        MODEL: 'model',
      };
      
      // --- Inlined from services/geminiService.ts ---
      if (!process.env.API_KEY) {
          throw new Error("API_KEY environment variable not set");
      }
      const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
      const SYSTEM_INSTRUCTION_TEMPLATE = `You are an expert assistant. Your name is NotebookLM Assistant. 
      You must answer questions based ONLY on the following source material provided. 
      Do not use any external knowledge or your pre-trained knowledge. 
      If the answer cannot be found in the source material, you must state that the information is not available in the provided context. 
      Be concise, helpful, and cite which part of the source you are referring to if possible.

      Here is the source material:
      ---START OF SOURCE---
      {sourceText}
      ---END OF SOURCE---`;

      function createNotebookChatSession(sourceText) {
          const systemInstruction = SYSTEM_INSTRUCTION_TEMPLATE.replace('{sourceText}', sourceText);

          const chat = ai.chats.create({
              model: 'gemini-2.5-flash',
              config: {
                  systemInstruction: systemInstruction,
              },
              history: [],
          });
          return chat;
      }

      // Ollama API 호출 함수
      async function callOllamaAPI(message, sourceText, model = 'solar:10.7b') {
          const systemInstruction = SYSTEM_INSTRUCTION_TEMPLATE.replace('{sourceText}', sourceText);
          
          const payload = {
              model: model,
              messages: [
                  {
                      role: 'system',
                      content: systemInstruction
                  },
                  {
                      role: 'user',
                      content: message
                  }
              ],
              stream: false,
              options: {
                  temperature: 0.7,
                  top_p: 0.9,
                  max_tokens: 2048
              }
          };

          try {
              const response = await fetch(`${process.env.OLLAMA_BASE_URL}/api/chat`, {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                  },
                  body: JSON.stringify(payload)
              });

              if (!response.ok) {
                  throw new Error(`Ollama API error: ${response.status} ${response.statusText}`);
              }

              const data = await response.json();
              
              if (data.message && data.message.content) {
                  return data.message.content.trim();
              } else {
                  throw new Error('Invalid response format from Ollama API');
              }
          } catch (error) {
              throw new Error(`Ollama API call failed: ${error.message}`);
          }
      }

      // Ollama 스트림 API 호출 함수
      async function* callOllamaStreamAPI(message, sourceText, model = 'solar:10.7b') {
          const systemInstruction = SYSTEM_INSTRUCTION_TEMPLATE.replace('{sourceText}', sourceText);
          
          const payload = {
              model: model,
              messages: [
                  {
                      role: 'system',
                      content: systemInstruction
                  },
                  {
                      role: 'user',
                      content: message
                  }
              ],
              stream: true,
              options: {
                  temperature: 0.7,
                  top_p: 0.9,
                  max_tokens: 2048
              }
          };

          try {
              const response = await fetch(`${process.env.OLLAMA_BASE_URL}/api/chat`, {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                  },
                  body: JSON.stringify(payload)
              });

              if (!response.ok) {
                  throw new Error(`Ollama API error: ${response.status} ${response.statusText}`);
              }

              const reader = response.body?.getReader();
              if (!reader) {
                  throw new Error('No response body reader available');
              }

              const decoder = new TextDecoder();

              while (true) {
                  const { done, value } = await reader.read();
                  if (done) break;

                  const chunk = decoder.decode(value);
                  const lines = chunk.split('\n').filter(line => line.trim());

                  for (const line of lines) {
                      try {
                          const data = JSON.parse(line);
                          if (data.message && data.message.content) {
                              yield { text: data.message.content };
                          }
                      } catch (e) {
                          // JSON 파싱 실패는 무시
                      }
                  }
              }
          } catch (error) {
              throw new Error(`Ollama stream API call failed: ${error.message}`);
          }
      }

      // --- Inlined from components/icons/UserIcon.tsx ---
      const UserIcon = ({ className = "w-6 h-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z" />
          </svg>
      );

      // --- Inlined from components/icons/BotIcon.tsx ---
      const BotIcon = ({ className = "w-6 h-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
              <path d="M19.98 10.98c0-4.96-4.02-8.98-8.98-8.98S2 6.02 2 10.98v3.03c0 .54.44.99.99.99h1.01V12h-2c0-4.41 3.59-8 8-8s8 3.59 8 8v2.01h-2v-2.01c0-.54-.44-.99-.99-.99H18v2.01h2v-2.04zM12 15c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm1.5-1.5c0-.83-.67-1.5-1.5-1.5S12 10.67 12 11.5s.67 1.5 1.5 1.5.5-.67.5-1.5z" opacity=".3" />
              <path d="M21 12v-1.02c0-4.96-4.02-8.98-8.98-8.98S3.04 6.02 3.04 10.98V12H2v2.01h1.05v2.99c0 .54.44.99.99.99H6v-2.01H4.04v-2.99H20v2.99h-2.01V20h2.01c.54 0 .99-.44.99-.99v-2.99H22V12h-1zm-9 3c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm1.5-1.5c0-.83-.67-1.5-1.5-1.5S10.5 10.67 10.5 11.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5z" />
          </svg>
      );

      // --- Inlined from components/icons/SendIcon.tsx ---
      const SendIcon = ({ className = "w-6 h-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
              <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" />
          </svg>
      );
      
      // --- Inlined from components/icons/DocumentIcon.tsx ---
      const DocumentIcon = ({ className = "w-6 h-6" }) => (
        <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m-1.5 0-3.75 3.75m3.75-3.75V4.5m0 13.5h-3a1.5 1.5 0 0 1-1.5-1.5v-10.5a1.5 1.5 0 0 1 1.5-1.5h3.75a1.5 1.5 0 0 1 1.5 1.5v10.5a1.5 1.5 0 0 1-1.5-1.5h-3.75Z" />
        </svg>
      );

      // --- New Component: LlmSelector ---
      const LlmSelector = ({ 
        currentService, 
        onServiceChange, 
        onModelChange, 
        className = "" 
      }) => {
        const [availableServices, setAvailableServices] = useState([
          {
            type: 'gemini',
            name: 'Google Gemini',
            description: 'Google의 Gemini API 서비스 (인터넷 연결 필요)',
            available: !!process.env.API_KEY
          },
          {
            type: 'ollama',
            name: 'Ollama (로컬)',
            description: '로컬 Ollama 서버 (오프라인 가능)',
            available: true
          }
        ]);
        
        const [availableModels, setAvailableModels] = useState([]);
        const [currentModel, setCurrentModel] = useState('');
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);

        // Ollama 모델 목록 조회
        React.useEffect(() => {
          if (currentService === 'ollama') {
            const fetchModels = async () => {
              try {
                setIsLoading(true);
                setError(null);
                
                // Ollama API에서 실제 설치된 모델 목록 가져오기
                const response = await fetch('http://localhost:11434/api/tags');
                if (!response.ok) {
                  throw new Error(`Ollama 서버 연결 실패: ${response.status}`);
                }
                
                const data = await response.json();
                const installedModels = data.models || [];
                
                // 설치된 모델들을 OllamaModel 형식으로 변환
                const models = installedModels.map((model) => {
                  const sizeInGB = Math.round((model.size || 0) / (1024 * 1024 * 1024) * 100) / 100;
                  const isRecommended = model.name.includes('exaone') || model.name.includes('solar');
                  
                  return {
                    name: model.name,
                    size: sizeInGB,
                    description: getModelDescription(model.name),
                    recommended: isRecommended
                  };
                });
                
                // exaone 모델을 맨 앞으로 정렬
                models.sort((a, b) => {
                  if (a.name.includes('exaone') && !b.name.includes('exaone')) return -1;
                  if (!a.name.includes('exaone') && b.name.includes('exaone')) return 1;
                  return a.name.localeCompare(b.name);
                });
                
                setAvailableModels(models);
                
                // exaone 모델이 있으면 기본값으로 설정, 없으면 첫 번째 모델 선택
                const exaoneModel = models.find(m => m.name.includes('exaone'));
                setCurrentModel(exaoneModel?.name || models[0]?.name || '');
                
              } catch (err) {
                console.error('Failed to fetch models:', err);
                setError('모델 목록을 불러올 수 없습니다. Ollama 서버가 실행 중인지 확인해주세요.');
              } finally {
                setIsLoading(false);
              }
            };

            fetchModels();
          }
        }, [currentService]);

        // 모델 설명 생성 함수
        const getModelDescription = (modelName) => {
          if (modelName.includes('exaone')) {
            return 'Exaone 3.5 - 한국어 특화 고성능 모델';
          } else if (modelName.includes('solar')) {
            return 'Solar - 고성능 한국어 특화 모델';
          } else if (modelName.includes('llama3.2')) {
            return 'Meta LLaMA 3.2 - 최신 Meta 모델';
          } else if (modelName.includes('llama3.1')) {
            return 'Meta LLaMA 3.1 - 안정적 성능의 Meta 모델';
          } else if (modelName.includes('deepseek')) {
            return 'DeepSeek R1 - 고성능 추론 모델';
          } else if (modelName.includes('timHan')) {
            return 'TimHan LLaMA Korean - 한국어 특화 모델';
          } else if (modelName.includes('mistral')) {
            return 'Mistral - 고성능 소형 모델';
          } else if (modelName.includes('codellama')) {
            return 'Code Llama - 코드 특화 모델';
          } else if (modelName.includes('qwen')) {
            return 'Qwen - 다국어 지원 모델';
          } else if (modelName.includes('gemma')) {
            return 'Google Gemma - Google 모델';
          } else {
            return `${modelName} - 사용자 정의 모델`;
          }
        };

        const handleServiceChange = async (serviceType) => {
          try {
            setIsLoading(true);
            setError(null);
            await onServiceChange(serviceType);
          } catch (err) {
            setError(`서비스 변경 실패: ${err.message}`);
          } finally {
            setIsLoading(false);
          }
        };

        const handleModelChange = async (modelName) => {
          try {
            setIsLoading(true);
            setError(null);
            setCurrentModel(modelName);
            if (onModelChange) {
              await onModelChange(modelName);
            }
          } catch (err) {
            setError(`모델 변경 실패: ${err.message}`);
          } finally {
            setIsLoading(false);
          }
        };

        const formatModelSize = (size) => `${size}GB`;

        const getMemoryStatus = (size) => {
          if (size <= 4) return { color: 'text-green-400', text: '메모리 충분' };
          if (size <= 8) return { color: 'text-yellow-400', text: '메모리 주의' };
          return { color: 'text-red-400', text: '메모리 부족' };
        };

        return (
          <div className={`bg-brand-surface rounded-lg p-4 space-y-4 ${className}`}>
            <h3 className="text-lg font-semibold text-brand-primary">LLM 설정</h3>
            
            {error && (
              <div className="flex items-center gap-2 text-red-400 bg-red-900/20 p-2 rounded">
                <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                </svg>
                <span className="text-sm">{error}</span>
              </div>
            )}

            <div className="space-y-2">
              <label className="text-sm font-medium text-brand-text-primary">AI 서비스</label>
              <div className="grid grid-cols-1 gap-2">
                {availableServices.map((service) => (
                  <button
                    key={service.type}
                    onClick={() => handleServiceChange(service.type)}
                    disabled={!service.available || isLoading}
                    className={`p-3 rounded-lg border-2 transition-all text-left ${
                      currentService === service.type
                        ? 'border-brand-primary bg-brand-primary/10'
                        : 'border-brand-secondary hover:border-brand-primary/50'
                    } ${
                      !service.available
                        ? 'opacity-50 cursor-not-allowed'
                        : 'cursor-pointer'
                    }`}
                  >
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="font-medium text-brand-text-primary">{service.name}</div>
                        <div className="text-sm text-brand-text-secondary">{service.description}</div>
                      </div>
                      <div className="flex items-center gap-2">
                        {!service.available && (
                          <span className="text-xs text-red-400">사용 불가</span>
                        )}
                        {currentService === service.type && (
                          <div className="w-2 h-2 bg-brand-primary rounded-full"></div>
                        )}
                      </div>
                    </div>
                  </button>
                ))}
              </div>
            </div>

            {currentService === 'ollama' && (
              <div className="space-y-2">
                <label className="text-sm font-medium text-brand-text-primary">모델 선택</label>
                {isLoading ? (
                  <div className="flex items-center justify-center p-4">
                    <div className="w-6 h-6 border-2 border-brand-primary border-t-transparent rounded-full animate-spin"></div>
                    <span className="ml-2 text-brand-text-secondary">모델 목록 로딩 중...</span>
                  </div>
                ) : (
                  <div className="space-y-2 max-h-60 overflow-y-auto">
                    {availableModels.map((model) => {
                      const memoryStatus = getMemoryStatus(model.size);
                      return (
                        <button
                          key={model.name}
                          onClick={() => handleModelChange(model.name)}
                          disabled={isLoading}
                          className={`w-full p-3 rounded-lg border-2 transition-all text-left ${
                            currentModel === model.name
                              ? 'border-brand-primary bg-brand-primary/10'
                              : 'border-brand-secondary hover:border-brand-primary/50'
                          }`}
                        >
                          <div className="flex items-start justify-between">
                            <div className="flex-1">
                              <div className="flex items-center gap-2">
                                <span className="font-medium text-brand-text-primary">{model.name}</span>
                                {model.recommended && (
                                  <span className="px-2 py-1 text-xs bg-green-600 text-white rounded">추천</span>
                                )}
                              </div>
                              <div className="text-sm text-brand-text-secondary mt-1">{model.description}</div>
                              <div className="flex items-center gap-4 mt-2 text-xs">
                                <span className="text-brand-text-secondary">크기: {formatModelSize(model.size)}</span>
                                <span className={memoryStatus.color}>{memoryStatus.text}</span>
                              </div>
                            </div>
                            {currentModel === model.name && (
                              <div className="w-2 h-2 bg-brand-primary rounded-full mt-2"></div>
                            )}
                          </div>
                        </button>
                      );
                    })}
                  </div>
                )}
              </div>
            )}

            <div className="pt-2 border-t border-brand-secondary">
              <div className="text-sm text-brand-text-secondary">
                <div className="flex justify-between">
                  <span>현재 서비스:</span>
                  <span className="text-brand-text-primary">
                    {availableServices.find(s => s.type === currentService)?.name || 'Unknown'}
                  </span>
                </div>
                {currentService === 'ollama' && currentModel && (
                  <div className="flex justify-between mt-1">
                    <span>현재 모델:</span>
                    <span className="text-brand-text-primary">{currentModel}</span>
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      };

      // --- New Component: SourceInfo ---
      const SourceInfo = ({ isLoading, files }) => (
          <div className="flex flex-col h-full bg-brand-surface rounded-lg p-4">
              <h2 className="text-lg font-semibold text-brand-primary mb-3">자료 출처</h2>
              {isLoading ? (
                  <div className="flex flex-col items-center justify-center flex-1">
                      <div className="w-8 h-8 border-4 border-brand-primary border-t-transparent rounded-full animate-spin mb-4"></div>
                      <p className="text-brand-text-primary">문서 목록 확인 및 로딩 중...</p>
                      <p className="text-sm text-brand-text-secondary">자료를 준비하고 있습니다.</p>
                  </div>
              ) : (
                  <div>
                      <p className="text-sm text-brand-text-secondary mb-4">
                          챗봇은 아래 문서들을 기반으로 답변합니다.
                      </p>
                      <ul className="space-y-2">
                          {files.map((file, index) => (
                              <li key={index} className="flex items-center gap-2 text-brand-text-secondary text-sm">
                                  <DocumentIcon className="w-5 h-5 flex-shrink-0" />
                                  <span>{file}</span>
                              </li>
                          ))}
                      </ul>
                  </div>
              )}
          </div>
      );
      
      // --- Inlined from components/Message.tsx ---
      const Message = ({ message }) => {
          const isUser = message.role === Role.USER;

          return (
              <div className={`flex items-start gap-4 p-4 ${isUser ? '' : 'bg-brand-surface/50 rounded-lg'}`}>
                  <div className={`flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center ${isUser ? 'bg-brand-secondary' : 'bg-brand-primary'}`}>
                      {isUser ? <UserIcon className="w-5 h-5 text-brand-text-primary" /> : <BotIcon className="w-5 h-5 text-brand-bg" />}
                  </div>
                  <div className="flex-1 pt-1">
                      <p className="font-semibold text-brand-text-primary mb-1">{isUser ? 'You' : 'Assistant'}</p>
                      <p className="text-brand-text-secondary whitespace-pre-wrap">{message.content}</p>
                  </div>
              </div>
          );
      };
      
      // --- Inlined from components/StatusIndicator.tsx ---
      const StatusIndicator = ({ 
          cacheStats, 
          queueStatus, 
          isLoading = false, 
          error = null, 
          className = "" 
      }) => {
          const formatBytes = (bytes) => {
              if (bytes === 0) return '0 Bytes';
              const k = 1024;
              const sizes = ['Bytes', 'KB', 'MB', 'GB'];
              const i = Math.floor(Math.log(bytes) / Math.log(k));
              return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
          };

          const formatPercentage = (value) => {
              return (value * 100).toFixed(1) + '%';
          };

          return (
              <div className={`bg-brand-surface rounded-lg p-4 space-y-3 ${className}`}>
                  <h3 className="text-lg font-semibold text-brand-primary mb-3">시스템 상태</h3>
                  
                  {/* 로딩 상태 */}
                  {isLoading && (
                      <div className="flex items-center gap-2 text-brand-text-secondary">
                          <div className="w-4 h-4 border-2 border-brand-primary border-t-transparent rounded-full animate-spin"></div>
                          <span>처리 중...</span>
                      </div>
                  )}

                  {/* 에러 상태 */}
                  {error && (
                      <div className="flex items-center gap-2 text-red-400 bg-red-900/20 p-2 rounded">
                          <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                          </svg>
                          <span className="text-sm">{error}</span>
                      </div>
                  )}

                  {/* 캐시 상태 */}
                  {cacheStats && (
                      <div className="space-y-2">
                          <h4 className="text-sm font-medium text-brand-text-primary">캐시 상태</h4>
                          <div className="grid grid-cols-2 gap-2 text-sm">
                              <div className="flex justify-between">
                                  <span className="text-brand-text-secondary">항목 수:</span>
                                  <span className="text-brand-text-primary">{cacheStats.totalItems}</span>
                              </div>
                              <div className="flex justify-between">
                                  <span className="text-brand-text-secondary">히트율:</span>
                                  <span className="text-brand-text-primary">{formatPercentage(cacheStats.hitRate)}</span>
                              </div>
                              <div className="flex justify-between col-span-2">
                                  <span className="text-brand-text-secondary">총 크기:</span>
                                  <span className="text-brand-text-primary">{formatBytes(cacheStats.totalSize)}</span>
                              </div>
                          </div>
                          
                          {/* 히트율 시각화 */}
                          <div className="w-full bg-brand-secondary rounded-full h-2">
                              <div 
                                  className="bg-brand-primary h-2 rounded-full transition-all duration-300"
                                  style={{ width: `${cacheStats.hitRate * 100}%` }}
                              ></div>
                          </div>
                      </div>
                  )}

                  {/* 요청 큐 상태 */}
                  {queueStatus && (
                      <div className="space-y-2">
                          <h4 className="text-sm font-medium text-brand-text-primary">요청 큐</h4>
                          <div className="grid grid-cols-2 gap-2 text-sm">
                              <div className="flex justify-between">
                                  <span className="text-brand-text-secondary">대기:</span>
                                  <span className="text-yellow-400">{queueStatus.pendingCount}</span>
                              </div>
                              <div className="flex justify-between">
                                  <span className="text-brand-text-secondary">처리중:</span>
                                  <span className="text-blue-400">{queueStatus.processingCount}</span>
                              </div>
                              <div className="flex justify-between">
                                  <span className="text-brand-text-secondary">실패:</span>
                                  <span className="text-red-400">{queueStatus.failedCount}</span>
                              </div>
                              <div className="flex justify-between">
                                  <span className="text-brand-text-secondary">총 큐:</span>
                                  <span className="text-brand-text-primary">{queueStatus.totalLength}</span>
                              </div>
                          </div>
                      </div>
                  )}

                  {/* 시스템 상태 요약 */}
                  <div className="pt-2 border-t border-brand-secondary">
                      <div className="flex items-center justify-between text-sm">
                          <span className="text-brand-text-secondary">시스템 상태:</span>
                          <div className="flex items-center gap-1">
                              {error ? (
                                  <>
                                      <div className="w-2 h-2 bg-red-400 rounded-full"></div>
                                      <span className="text-red-400">오류</span>
                                  </>
                              ) : isLoading ? (
                                  <>
                                      <div className="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
                                      <span className="text-yellow-400">처리중</span>
                                  </>
                              ) : (
                                  <>
                                      <div className="w-2 h-2 bg-green-400 rounded-full"></div>
                                      <span className="text-green-400">정상</span>
                                  </>
                              )}
                          </div>
                      </div>
                  </div>
              </div>
          );
      };

      // --- Inlined from components/CacheStats.tsx ---
      const CacheStats = ({ 
          stats, 
          onClearCache, 
          className = "" 
      }) => {
          const formatBytes = (bytes) => {
              if (bytes === 0) return '0 Bytes';
              const k = 1024;
              const sizes = ['Bytes', 'KB', 'MB', 'GB'];
              const i = Math.floor(Math.log(bytes) / Math.log(k));
              return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
          };

          const formatPercentage = (value) => {
              return (value * 100).toFixed(1) + '%';
          };

          const getHitRateColor = (rate) => {
              if (rate >= 0.7) return 'text-green-400';
              if (rate >= 0.4) return 'text-yellow-400';
              return 'text-red-400';
          };

          const getHitRateBarColor = (rate) => {
              if (rate >= 0.7) return 'bg-green-400';
              if (rate >= 0.4) return 'bg-yellow-400';
              return 'bg-red-400';
          };

          return (
              <div className={`bg-brand-surface rounded-lg p-4 space-y-4 ${className}`}>
                  <div className="flex items-center justify-between">
                      <h3 className="text-lg font-semibold text-brand-primary">캐시 통계</h3>
                      {onClearCache && (
                          <button
                              onClick={onClearCache}
                              className="px-3 py-1 text-xs bg-red-600 hover:bg-red-700 text-white rounded transition-colors"
                          >
                              캐시 초기화
                          </button>
                      )}
                  </div>

                  {/* 히트율 표시 */}
                  <div className="space-y-2">
                      <div className="flex items-center justify-between">
                          <span className="text-sm font-medium text-brand-text-primary">캐시 히트율</span>
                          <span className={`text-lg font-bold ${getHitRateColor(stats.hitRate)}`}>
                              {formatPercentage(stats.hitRate)}
                          </span>
                      </div>
                      
                      {/* 히트율 프로그레스 바 */}
                      <div className="w-full bg-brand-secondary rounded-full h-3">
                          <div 
                              className={`h-3 rounded-full transition-all duration-500 ${getHitRateBarColor(stats.hitRate)}`}
                              style={{ width: `${stats.hitRate * 100}%` }}
                          ></div>
                      </div>
                      
                      {/* 히트/미스 카운트 */}
                      <div className="flex justify-between text-xs text-brand-text-secondary">
                          <span>히트: {stats.hitCount}</span>
                          <span>미스: {stats.missCount}</span>
                      </div>
                  </div>

                  {/* 기본 통계 */}
                  <div className="grid grid-cols-2 gap-3 text-sm">
                      <div className="space-y-1">
                          <div className="flex justify-between">
                              <span className="text-brand-text-secondary">총 항목:</span>
                              <span className="text-brand-text-primary font-medium">{stats.totalItems}</span>
                          </div>
                          <div className="flex justify-between">
                              <span className="text-brand-text-secondary">만료된 항목:</span>
                              <span className="text-orange-400">{stats.expiredItems}</span>
                          </div>
                      </div>
                      
                      <div className="space-y-1">
                          <div className="flex justify-between">
                              <span className="text-brand-text-secondary">총 크기:</span>
                              <span className="text-brand-text-primary font-medium">{formatBytes(stats.totalSize)}</span>
                          </div>
                          <div className="flex justify-between">
                              <span className="text-brand-text-secondary">평균 크기:</span>
                              <span className="text-brand-text-primary">{formatBytes(stats.averageItemSize)}</span>
                          </div>
                      </div>
                  </div>

                  {/* 가장 많이 접근된 항목 */}
                  {stats.mostAccessedItem && (
                      <div className="pt-2 border-t border-brand-secondary">
                          <div className="text-xs text-brand-text-secondary">
                              <span className="font-medium">가장 많이 접근된 항목:</span>
                              <div className="mt-1 p-2 bg-brand-bg rounded text-brand-text-primary font-mono text-xs truncate">
                                  {stats.mostAccessedItem}
                              </div>
                          </div>
                      </div>
                  )}

                  {/* 성능 지표 */}
                  <div className="pt-2 border-t border-brand-secondary">
                      <div className="text-xs text-brand-text-secondary space-y-1">
                          <div className="flex justify-between">
                              <span>API 호출 절약:</span>
                              <span className="text-green-400 font-medium">
                                  {formatPercentage(stats.hitRate)} 감소
                              </span>
                          </div>
                          <div className="flex justify-between">
                              <span>예상 응답 시간:</span>
                              <span className="text-blue-400 font-medium">
                                  {stats.hitRate > 0.5 ? '< 100ms' : '1-2초'}
                              </span>
                          </div>
                      </div>
                  </div>
              </div>
          );
      };

      // --- Inlined from components/MessageInput.tsx ---
      const MessageInput = ({ 
          currentMessage, 
          setCurrentMessage, 
          onSendMessage, 
          isLoading, 
          disabled,
          lastMessageTime = 0,
          maxLength = 500,
          minInterval = 5000,  // 5초 간격으로 변경
          retryCountdown = 0,
          lastSentMessage = ''
      }) => {
          const [inputError, setInputError] = useState('');
          const [remainingTime, setRemainingTime] = useState(0);
          
          const isInputDisabled = isLoading || disabled || remainingTime > 0;
          const timeSinceLastMessage = Date.now() - lastMessageTime;
          const canSend = timeSinceLastMessage >= minInterval;
          
          // 남은 시간 계산
          useEffect(() => {
              if (!canSend && lastMessageTime > 0) {
                  const interval = setInterval(() => {
                      const elapsed = Date.now() - lastMessageTime;
                      const remaining = Math.max(0, minInterval - elapsed);
                      setRemainingTime(remaining);
                      
                      if (remaining === 0) {
                          clearInterval(interval);
                      }
                  }, 100);
                  
                  return () => clearInterval(interval);
              }
          }, [canSend, lastMessageTime, minInterval]);
          
          // 입력 검증
          const handleInputChange = (e) => {
              const value = e.target.value;
              
              // 길이 제한
              if (value.length > maxLength) {
                  setInputError(`메시지는 ${maxLength}자를 초과할 수 없습니다.`);
                  return;
              }
              
              // 에러 메시지 초기화
              setInputError('');
              setCurrentMessage(value);
          };
          
          // 전송 처리
          const handleSubmit = (e) => {
              e.preventDefault();
              
              if (!currentMessage.trim()) {
                  setInputError('메시지를 입력해주세요.');
                  return;
              }
              
              if (!canSend) {
                  setInputError(`잠시 후 다시 시도해주세요. (${Math.ceil(remainingTime / 1000)}초 남음)`);
                  return;
              }
              
              // 중복 메시지 검사 (선택적 - 필요시 활성화)
              // if (currentMessage.trim() === lastSentMessage.trim()) {
              //     setInputError('동일한 메시지를 연속으로 보낼 수 없습니다.');
              //     return;
              // }
              
              setInputError('');
              onSendMessage(e);
          };
          
          const formatTime = (ms) => {
              return Math.ceil(ms / 1000);
          };

          return (
              <form onSubmit={handleSubmit} className="p-4 bg-brand-surface">
                  {/* 입력 제한 상태 표시 */}
                  {remainingTime > 0 && (
                      <div className="mb-2 p-2 bg-yellow-900/20 border border-yellow-600/30 rounded text-yellow-300 text-sm">
                          <div className="flex items-center gap-2">
                              <div className="w-4 h-4 border-2 border-yellow-400 border-t-transparent rounded-full animate-spin"></div>
                              <span>다음 메시지까지 {formatTime(remainingTime)}초 대기 중...</span>
                          </div>
                      </div>
                  )}
                  
                  {/* 에러 메시지 */}
                  {inputError && (
                      <div className="mb-2 p-2 bg-red-900/20 border border-red-600/30 rounded text-red-300 text-sm">
                          {inputError}
                      </div>
                  )}
                  
                  <div className="relative">
                      <input
                          type="text"
                          value={currentMessage}
                          onChange={handleInputChange}
                          onKeyDown={(e) => {
                              // 스페이스바 입력 보장
                              if (e.key === ' ') {
                                  e.stopPropagation();
                              }
                          }}
                          onKeyUp={(e) => {
                              // 스페이스바 입력 보장
                              if (e.key === ' ') {
                                  e.stopPropagation();
                              }
                          }}
                          placeholder={
                              disabled ? "자료를 로딩 중입니다..." : 
                              retryCountdown > 0 ? `질문을 입력하세요 (${Math.floor(retryCountdown / 60)}:${String(retryCountdown % 60).padStart(2, '0')} 후 전송 가능)` :
                              remainingTime > 0 ? `잠시 후 다시 시도해주세요...` :
                              "질문을 입력하세요..."
                          }
                          disabled={isInputDisabled}
                          className="w-full bg-brand-bg border border-brand-secondary rounded-full py-3 pl-4 pr-12 text-brand-text-primary focus:outline-none focus:ring-2 focus:ring-brand-primary disabled:opacity-50"
                          maxLength={maxLength}
                      />
                      <button
                          type="submit"
                          disabled={isInputDisabled || !currentMessage.trim() || retryCountdown > 0}
                          title={
                              retryCountdown > 0 ? `API 한도 초과 - ${Math.floor(retryCountdown / 60)}:${String(retryCountdown % 60).padStart(2, '0')} 후 사용 가능` :
                              remainingTime > 0 ? "잠시 후 다시 시도해주세요" :
                              isLoading ? "처리 중입니다..." :
                              !currentMessage.trim() ? "질문을 입력하세요" :
                              "전송"
                          }
                          className="absolute right-2 top-1/2 -translate-y-1/2 p-2 rounded-full text-brand-primary hover:bg-brand-primary/20 disabled:text-brand-secondary disabled:hover:bg-transparent transition-colors"
                      >
                          <SendIcon className="w-6 h-6" />
                      </button>
                  </div>
                  
                  {/* 글자 수 표시 */}
                  <div className="mt-2 flex justify-between text-xs text-brand-text-secondary">
                      <span>{currentMessage.length} / {maxLength}자</span>
                      {lastMessageTime > 0 && (
                          <span>
                              마지막 메시지: {formatTime(timeSinceLastMessage)}초 전
                          </span>
                      )}
                  </div>
              </form>
          );
      };

      // --- Inlined from components/ChatWindow.tsx ---
      const ChatWindow = ({ messages, isLoading, sourceProvided, isParsingDocs }) => {
          const scrollRef = useRef(null);

          useEffect(() => {
              if (scrollRef.current) {
                  scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
              }
          }, [messages, isLoading]);

          return (
              <div ref={scrollRef} className="flex-1 overflow-y-auto p-4 space-y-4">
                   {messages.length === 0 && isParsingDocs && (
                        <div className="text-center text-brand-text-secondary p-8 flex flex-col items-center justify-center h-full">
                            <div className="w-8 h-8 border-4 border-brand-primary border-t-transparent rounded-full animate-spin mb-4"></div>
                            <h3 className="text-xl font-semibold text-brand-text-primary">자료 로딩 중</h3>
                            <p>챗봇을 시작하기 위해 문서를 준비하고 있습니다.</p>
                        </div>
                   )}
                   {messages.length === 0 && !isParsingDocs && !sourceProvided && (
                        <div className="text-center text-brand-text-secondary p-8 flex flex-col items-center justify-center h-full">
                            <DocumentIcon className="w-12 h-12 mb-4 text-brand-secondary" />
                            <h3 className="text-xl font-semibold text-brand-text-primary">오류 발생</h3>
                            <p>문서 로딩에 실패했습니다. 페이지를 새로고침 해주세요.</p>
                        </div>
                   )}
                   {messages.length === 0 && !isParsingDocs && sourceProvided && (
                      <div className="text-center text-brand-text-secondary p-8 flex flex-col items-center">
                          <BotIcon className="w-12 h-12 mb-4 text-brand-primary" />
                          <h3 className="text-xl font-semibold text-brand-text-primary">채팅 준비 완료</h3>
                          <p>문서가 로드되었습니다. 질문을 시작하세요.</p>
                      </div>
                  )}
                  {messages.map((msg, index) => (
                      <Message key={index} message={msg} />
                  ))}
                  {isLoading && messages.length > 0 && messages[messages.length - 1].role === 'user' && (
                       <div className="flex items-start gap-4 p-4 bg-brand-surface/50 rounded-lg">
                          <div className="flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center bg-brand-primary">
                              <BotIcon className="w-5 h-5 text-brand-bg" />
                          </div>
                          <div className="flex-1 pt-1">
                              <p className="font-semibold text-brand-text-primary mb-1">Assistant</p>
                              <div className="flex items-center gap-2">
                                  <span className="w-2 h-2 bg-brand-text-secondary rounded-full animate-pulse [animation-delay:-0.3s]"></span>
                                  <span className="w-2 h-2 bg-brand-text-secondary rounded-full animate-pulse [animation-delay:-0.15s]"></span>
                                  <span className="w-2 h-2 bg-brand-text-secondary rounded-full animate-pulse"></span>
                              </div>
                          </div>
                      </div>
                  )}
              </div>
          );
      };

      // --- Inlined from App.tsx ---
      const App = () => {
          const [sourceText, setSourceText] = useState('');
          const [messages, setMessages] = useState([]);
          const [currentMessage, setCurrentMessage] = useState('');
          const [isLoading, setIsLoading] = useState(false);
          const [lastSentMessage, setLastSentMessage] = useState('');
          const [isParsing, setIsParsing] = useState(true);
          const [discoveredFiles, setDiscoveredFiles] = useState([]);
          const [error, setError] = useState(null);
          
          // LLM 서비스 관련 상태
          const [currentLlmService, setCurrentLlmService] = useState(LlmServiceType.OLLAMA);
          const [currentModel, setCurrentModel] = useState('solar:10.7b');
          
          // 새로운 상태 추가
          const [lastMessageTime, setLastMessageTime] = useState(0);
          const [cacheStats, setCacheStats] = useState({
              totalItems: 0,
              hitRate: 0,
              totalSize: 0
          });
          const [queueStatus, setQueueStatus] = useState({
              totalLength: 0,
              pendingCount: 0,
              processingCount: 0,
              failedCount: 0
          });
          const [showStats, setShowStats] = useState(false);
          
          // 다음 시도 가능시간 관련 상태
          const [retryCountdown, setRetryCountdown] = useState(0);
          const [nextRetryTime, setNextRetryTime] = useState(null);

          const PDF_BASE_URL = 'https://ggawoos-bot.github.io/chat2/pdf/';

          // Ollama 서버 연결 확인
          const checkOllamaConnection = async () => {
            try {
              const response = await fetch(`${process.env.OLLAMA_BASE_URL}/api/tags`);
              if (!response.ok) {
                throw new Error(`Ollama server not responding: ${response.status}`);
              }
              return true;
            } catch (error) {
              throw new Error(`Cannot connect to Ollama server at ${process.env.OLLAMA_BASE_URL}. Please ensure Ollama is running.`);
            }
          };

          // LLM 서비스 변경 핸들러
          const handleLlmServiceChange = async (serviceType) => {
            try {
              if (serviceType === LlmServiceType.OLLAMA) {
                await checkOllamaConnection();
              }
              setCurrentLlmService(serviceType);
              // 서비스 변경 시 메시지 초기화
              setMessages([]);
              setError(null);
              console.log(`LLM 서비스가 ${serviceType}로 변경되었습니다.`);
            } catch (err) {
              setError(`서비스 변경 실패: ${err.message}`);
            }
          };

          // Ollama 모델 변경 핸들러
          const handleModelChange = async (modelName) => {
            try {
              setCurrentModel(modelName);
              console.log(`Ollama 모델이 ${modelName}로 변경되었습니다.`);
            } catch (err) {
              setError(`모델 변경 실패: ${err.message}`);
            }
          };

          const chatSession = useMemo(() => {
              if (sourceText.trim()) {
                  try {
                    return createNotebookChatSession(sourceText);
                  } catch (e) {
                    console.error("Error creating chat session:", e);
                    setError(e instanceof Error ? e.message : "Failed to create chat session.");
                    return null;
                  }
              }
              return null;
          }, [sourceText]);
          
          const parsePdfFromUrl = async (url) => {
              try {
                  const pdfData = await fetch(url).then(res => {
                      if (!res.ok) {
                          throw new Error(`Failed to fetch ${url}: ${res.statusText}`);
                      }
                      return res.arrayBuffer();
                  });
                  const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(pdfData) }).promise;
                  let fullText = '';
                  for (let i = 1; i <= pdf.numPages; i++) {
                      const page = await pdf.getPage(i);
                      const textContent = await page.getTextContent();
                      const pageText = textContent.items.map(item => item.str).join(' ');
                      fullText += pageText + '\n\n';
                  }
                  return fullText;
              } catch (err) {
                  console.error(`Error parsing PDF from ${url}:`, err);
                  throw new Error(`Failed to parse ${url.split('/').pop()}: ${err.message}`);
              }
          };

          useEffect(() => {
            const discoverAndParsePdfs = async () => {
                setIsParsing(true);
                setError(null);
                setSourceText('');
                setMessages([]);
                setDiscoveredFiles([]);

                try {
                    // Step 1: Fetch the manifest file to discover PDF files
                    const manifestUrl = `${PDF_BASE_URL}manifest.json`;
                    const manifestResponse = await fetch(manifestUrl);
                    if (!manifestResponse.ok) {
                        throw new Error(`Could not load file list (manifest.json). Status: ${manifestResponse.statusText}`);
                    }
                    const pdfFiles = await manifestResponse.json();

                    if (!Array.isArray(pdfFiles) || pdfFiles.length === 0) {
                        throw new Error("No PDF files found in manifest.json or the file is invalid.");
                    }
                    setDiscoveredFiles(pdfFiles);

                    // Step 2: Parse the discovered PDF files
                    const parsingPromises = pdfFiles.map(file => parsePdfFromUrl(PDF_BASE_URL + file));
                    const texts = await Promise.all(parsingPromises);
                    const combinedText = texts.join('\n--- END OF DOCUMENT ---\n\n--- START OF DOCUMENT ---\n');
                    setSourceText(combinedText);
                } catch (err) {
                    console.error("Error loading PDFs:", err);
                    setError(err instanceof Error ? err.message : 'An unknown error occurred during loading.');
                    setDiscoveredFiles([]); // Clear file list on error
                } finally {
                    setIsParsing(false);
                }
            };
            
            discoverAndParsePdfs();
        }, []); // Empty dependency array ensures this runs only once on mount

          const handleSendMessage = useCallback(async (e) => {
              e.preventDefault();
              if (!currentMessage.trim() || !chatSession || isLoading) return;
              
              // API 한도 초과 시 전송 차단
              if (retryCountdown > 0) {
                  setError(`🚫 API 한도 초과 - ${Math.floor(retryCountdown / 60)}:${String(retryCountdown % 60).padStart(2, '0')} 후 다시 시도해주세요.`);
                  return;
              }

              const userMessage = { role: Role.USER, content: currentMessage.trim() };
              setMessages(prev => [...prev, userMessage]);
              setLastSentMessage(currentMessage.trim()); // 마지막 전송된 메시지 저장
              setCurrentMessage('');
              setIsLoading(true);
              setError(null);
              setLastMessageTime(Date.now());

              try {
                  let modelResponse = '';
                  setMessages(prev => [...prev, { role: Role.MODEL, content: '' }]);

                  if (currentLlmService === LlmServiceType.GEMINI) {
                      // GEMINI API 사용
                      const stream = await chatSession.sendMessageStream({ message: userMessage.content });
                      for await (const chunk of stream) {
                          modelResponse += chunk.text;
                          setMessages(prev => {
                              const newMessages = [...prev];
                              newMessages[newMessages.length - 1].content = modelResponse;
                              return newMessages;
                          });
                      }
                  } else if (currentLlmService === LlmServiceType.OLLAMA) {
                      // Ollama API 사용
                      const stream = callOllamaStreamAPI(userMessage.content, sourceText, currentModel);
                      for await (const chunk of stream) {
                          modelResponse += chunk.text;
                          setMessages(prev => {
                              const newMessages = [...prev];
                              newMessages[newMessages.length - 1].content = modelResponse;
                              return newMessages;
                          });
                      }
                  }
                  
                  // 성공 시 통계 업데이트 (시뮬레이션)
                  updateStats();
                  
              } catch (err) {
                  console.error(err);
                  let displayMessage = '죄송합니다, 답변을 생성하는 중 오류가 발생했습니다. 잠시 후 다시 시도해 주세요.';

                  if (err instanceof Error && (err.message.includes('429') || err.message.includes('RESOURCE_EXHAUSTED') || err.message.includes('quota') || err.message.includes('limit'))) {
                      // 실제 API 한도 복구 시간 계산 (더 짧게)
                      let retryDelay;
                      if (err.message.includes('429')) {
                          // Rate limit - 30초 후 복구
                          retryDelay = 30 * 1000; // 30초
                      } else if (err.message.includes('RESOURCE_EXHAUSTED')) {
                          // Resource exhausted - 2분 후 복구
                          retryDelay = 2 * 60 * 1000; // 2분
                      } else {
                          // 기본값 - 1분
                          retryDelay = 1 * 60 * 1000; // 1분
                      }
                      
                      const nextRetry = new Date(Date.now() + retryDelay);
                      setNextRetryTime(nextRetry);
                      
                      const retryTimeString = nextRetry.toLocaleTimeString('ko-KR', {
                          hour: '2-digit',
                          minute: '2-digit'
                      });
                      
                      displayMessage = `🚫 답변 요청 한도를 초과했습니다.\n⏰ 다음 시도 가능 시간: ${retryTimeString}`;
                      
                      // 실시간 카운트다운 시작
                      const countdownSeconds = Math.floor(retryDelay / 1000);
                      setRetryCountdown(countdownSeconds);
                      const countdownTimer = setInterval(() => {
                          setRetryCountdown(prev => {
                              if (prev <= 1) {
                                  clearInterval(countdownTimer);
                                  setError(null);
                                  setNextRetryTime(null);
                                  return 0;
                              }
                              return prev - 1;
                          });
                      }, 1000);
                  }
                  
                  setError(displayMessage);
                  
                  setMessages(prev => {
                      const newMessages = [...prev];
                      if (newMessages.length > 0 && newMessages[newMessages.length - 1].role === Role.MODEL) {
                        newMessages.pop();
                      }
                      return [...newMessages, { role: Role.MODEL, content: displayMessage }];
                  });

              } finally {
                  setIsLoading(false);
              }
          }, [chatSession, currentMessage, isLoading]);

          // 통계 업데이트 함수 (시뮬레이션)
          const updateStats = useCallback(() => {
              // 캐시 통계 시뮬레이션
              setCacheStats(prev => ({
                  totalItems: prev.totalItems + Math.floor(Math.random() * 2),
                  hitRate: Math.min(0.9, prev.hitRate + Math.random() * 0.1),
                  totalSize: prev.totalSize + Math.floor(Math.random() * 1000)
              }));
              
              // 큐 상태 시뮬레이션
              setQueueStatus(prev => ({
                  totalLength: Math.max(0, prev.totalLength + Math.floor(Math.random() * 3) - 1),
                  pendingCount: Math.max(0, prev.pendingCount + Math.floor(Math.random() * 2) - 1),
                  processingCount: isLoading ? 1 : 0,
                  failedCount: Math.random() < 0.1 ? prev.failedCount + 1 : prev.failedCount
              }));
          }, [isLoading]);

          // 주기적 통계 업데이트
          useEffect(() => {
              const interval = setInterval(updateStats, 5000);
              return () => clearInterval(interval);
          }, [updateStats]);

          return (
              <div className="h-screen w-screen flex flex-col p-4 gap-4 bg-brand-bg">
                  <header className="text-center">
                      <h1 className="text-2xl font-bold text-brand-text-primary">금연사업 지침 문의 Chatbot</h1>
                  </header>
                  
                  <main className="flex-1 grid grid-cols-1 lg:grid-cols-3 gap-4 min-h-0">
                      {/* Source Info Column */}
                      <div className="flex flex-col min-h-0">
                           {/* LLM 선택 컴포넌트 */}
                           <LlmSelector
                                currentService={currentLlmService}
                                onServiceChange={handleLlmServiceChange}
                                onModelChange={handleModelChange}
                                className="mb-4"
                           />
                           
                           <SourceInfo
                                isLoading={isParsing}
                                files={discoveredFiles}
                           />
                           
                           {/* 상태 표시 컴포넌트 */}
                           <div className="mt-4">
                               <StatusIndicator
                                   cacheStats={cacheStats}
                                   queueStatus={queueStatus}
                                   isLoading={isLoading}
                                   error={error}
                               />
                           </div>
                           
                           {/* 통계 토글 버튼 */}
                           <div className="mt-4 flex justify-center">
                               <button
                                   onClick={() => setShowStats(!showStats)}
                                   className="px-4 py-2 bg-brand-primary hover:bg-brand-primary/80 text-brand-bg rounded-lg text-sm transition-colors"
                               >
                                   {showStats ? '통계 숨기기' : '상세 통계 보기'}
                               </button>
                           </div>
                           
                           {/* 상세 통계 */}
                           {showStats && (
                               <div className="mt-4">
                                   <CacheStats
                                       stats={{
                                           totalItems: cacheStats.totalItems,
                                           hitCount: Math.floor(cacheStats.hitRate * 100),
                                           missCount: Math.floor((1 - cacheStats.hitRate) * 100),
                                           hitRate: cacheStats.hitRate,
                                           totalSize: cacheStats.totalSize,
                                           averageItemSize: cacheStats.totalItems > 0 ? cacheStats.totalSize / cacheStats.totalItems : 0,
                                           expiredItems: 0,
                                           mostAccessedItem: '금연사업 지침 관련 질문'
                                       }}
                                       onClearCache={() => {
                                           setCacheStats({ totalItems: 0, hitRate: 0, totalSize: 0 });
                                           console.log('캐시 초기화됨');
                                       }}
                                   />
                               </div>
                           )}
                      </div>
                      
                      {/* Chat Column */}
                      <div className="flex flex-col h-full bg-brand-surface rounded-lg min-h-0 lg:col-span-2">
                          <div className="flex-1 flex flex-col min-h-0">
                            <div className="flex items-center justify-between p-4 border-b border-brand-secondary">
                                <h2 className="text-lg font-semibold text-brand-primary">질문하기</h2>
                                {/* 실시간 상태 표시 */}
                                <div className="flex items-center gap-2 text-sm text-brand-text-secondary">
                                    {isLoading && (
                                        <div className="flex items-center gap-1">
                                            <div className="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></div>
                                            <span>처리중</span>
                                        </div>
                                    )}
                                    {queueStatus.processingCount > 0 && (
                                        <div className="flex items-center gap-1">
                                            <div className="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
                                            <span>큐 처리중 ({queueStatus.processingCount})</span>
                                        </div>
                                    )}
                                    {cacheStats.hitRate > 0 && (
                                        <div className="flex items-center gap-1">
                                            <div className="w-2 h-2 bg-green-400 rounded-full"></div>
                                            <span>캐시 {(cacheStats.hitRate * 100).toFixed(0)}%</span>
                                        </div>
                                    )}
                                </div>
                            </div>
                              <>
                                 {error && (
                                     <div className="p-4 bg-red-900/50 text-red-300 border-b border-red-700">
                                         <div className="whitespace-pre-line text-sm">{error}</div>
                                         
                                         {retryCountdown > 0 && (
                                             <div className="mt-3 space-y-2">
                                                 {/* 카운트다운 표시 */}
                                                 <div className="flex items-center justify-between text-sm">
                                                     <div className="flex items-center gap-2">
                                                         <div className="w-3 h-3 border-2 border-yellow-400 border-t-transparent rounded-full animate-spin"></div>
                                                         <span>대기 중...</span>
                                                     </div>
                                                     <span className="font-mono text-yellow-300">
                                                         {Math.floor(retryCountdown / 60)}:{String(retryCountdown % 60).padStart(2, '0')}
                                                     </span>
                                                 </div>
                                                 
                                                 {/* 프로그레스 바 */}
                                                 <div className="w-full bg-red-800 rounded-full h-2">
                                                     <div 
                                                         className="bg-gradient-to-r from-yellow-400 to-green-400 h-2 rounded-full transition-all duration-1000"
                                                         style={{ width: `${100 - (retryCountdown / (retryCountdown > 0 ? Math.max(retryCountdown, 60) : 60)) * 100}%` }}
                                                     ></div>
                                                 </div>
                                                 
                                                 {/* 상태 메시지 */}
                                                 <div className="text-xs text-red-200">
                                                     {retryCountdown > 90 ? '🔴 API 한도 초과 - 대기 중' :
                                                      retryCountdown > 30 ? '🟡 복구 중 - 잠시만 기다려주세요' :
                                                      '🟢 곧 사용 가능합니다'}
                                                 </div>
                                             </div>
                                         )}
                                     </div>
                                 )}
                                 <ChatWindow 
                                     messages={messages} 
                                     isLoading={isLoading} 
                                     sourceProvided={!!chatSession}
                                     isParsingDocs={isParsing}
                                 />
                                  <MessageInput
                                      currentMessage={currentMessage}
                                      setCurrentMessage={setCurrentMessage}
                                      onSendMessage={handleSendMessage}
                                      isLoading={isLoading}
                                      disabled={!chatSession || isParsing || retryCountdown > 0}
                                      lastMessageTime={lastMessageTime}
                                      maxLength={500}
                                      minInterval={5000}
                                      retryCountdown={retryCountdown}
                                      lastSentMessage={lastSentMessage}
                                  />
                              </>
                          </div>
                      </div>
                  </main>
              </div>
          );
      };

      // --- Inlined from index.tsx ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <StrictMode>
          <App />
        </StrictMode>
      );
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>